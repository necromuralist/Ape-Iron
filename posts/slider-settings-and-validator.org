#+BEGIN_COMMENT
.. title: The Great Slidini
.. slug: slider-settings-and-validator
.. date: 2023-10-02 12:48:10 UTC-07:00
.. tags: javascript, p5
.. category: Javascript
.. link: 
.. description: A Slider Settings Class and Valdator
.. type: text
.. status: 
.. updated: 

#+END_COMMENT
#+OPTIONS: ^:{}
#+TOC: headlines 2

#+begin_src js :tangle ../javascript/slider.js :exports none
<<slider-settings-class>>

export { SliderSettings }
#+end_src

* The Validator

#+begin_src plantuml :file ../files/posts/slider-settings-and-validator/validator.png :exports none
!theme mars
class Validator {
Array emptiness
Object document

constructor(document)
is_a_number(identifier, acutal)
is_set(identifier, actual)
is_an_integer(identifier, actual)
is_an_element_id(identifier, actual_id)
}

Validator o- document
#+end_src

#+RESULTS:
[[file:../files/posts/slider-settings-and-validator/validator.png]]

[[img-url: validator.png][Validator UML]]

#+begin_src gherkin :tangle ../tests/cucumber-tests/test-slider-settings-and-validator/features/validator.feature :exports none
<<given-a-validator-scenario>>

<<is-a-number-scenario-1>>

<<is-a-number-scenario-2>>

<<is-a-number-scenario-3>>

<<is-set-scenario-1>>

<<is-set-scenario-2>>

<<is-set-scenario-3>>

<<is-integer-scenario-1>>

<<is-integer-scenario-2>>

<<is-integer-scenario-2a>>

<<is-id-scenario-1>>
#+end_src

#+begin_src js :tangle ../tests/cucumber-tests/test-slider-settings-and-validator/steps/validator_steps.js :exports none
import { expect } from "chai";
import { faker } from "@faker-js/faker";
import { Given, When, Then } from "@cucumber/cucumber";
import { JSDOM } from "jsdom";

// Software Under Test

import { Validator } from "../../../../javascript/validator.js"

// a fake document
<<validator-jsdom-setup>>

<<given-a-validator>>
  
<<is-a-number-case-1>>

<<is-a-number-case-2>>

<<is-a-number-case-3>>

<<is-set-case-1>>

<<is-set-case-2>>

<<is-set-case-3>>

<<is-an-integer-case-1>>

<<is-an-integer-case-2>>

<<is-an-integer-case-2a>>

<<is-an-integer-case-3>>

<<is-element-case-1>>

<<is-element-case-2>>
#+end_src

#+begin_src js :tangle ../javascript/validator.js :exports none
/** The Validator class checks if a value is a certain type
    It throws an error if any value is the wrong type

    Args:
     - document {Object} : something to grab DOM elements
   ,**/
<<validator-declaration>>

  <<validate-is-number>>

  <<validate-is-set>>

  <<validate-is-integer>>

  <<validate-is-id>>

  <<validate-throw-error>>
 }; // Validator

export { Validator }
#+end_src

The ~Validator~ class checks the type of a given value and throws an Error if it's not correct. It's meant to validate settings.

** Class Declaration

The constructor takes the ~document~ as an argument to make it testable and also to make explicit where it came from. The class also defines an array ~emptiness~ to hold the values that I'll use to check if a variable was set.

*** Setup JSDOM For Testing

This is the document that I'm passing to the ~Validator~ for testing.

#+begin_src js :noweb-ref validator-jsdom-setup
const VALID_ID = "validator-id";

const document = new JSDOM(`
<html>
<head></head>
<body>
 <div id=${VALID_ID}></div>
</body>
</html>
`).window.document;
#+end_src

*** Test And Implement The Validator Class

#+begin_src gherkin :noweb-ref given-a-validator-scenario
Feature: Validator
#+end_src

I don't have a "Given" statement in this part of the post even though I'm implementing the ~Given~ javascript here because each of the Scenarios after this re-use the same ~Given~ but I thought it made sense to go here since it sort of tests the existence of the ~Validator~.

#+begin_src js :noweb-ref given-a-validator
Given("a Validator", function() {
  this.validate = new Validator(document);
});
#+end_src

And here's the class definition that the ~Given~ is using.

#+begin_src js :noweb-ref validator-declaration
class Validator {
  emptiness = [null, undefined, NaN];

  constructor(document) {
    this.document = document;
  }
#+end_src

These blocks are the pattern That I'm going to follow for most of the rest of the code:

  1. Feature file fragment.
  2. Test implementation to match the feature file.
  3. Code implementation that's being tested.
     
** Is A Number

Our first method checks that a variable holds a number of some kind.

*** The Scenarios
#+begin_src gherkin :noweb-ref is-a-number-scenario-1
Scenario: The expected number is a number.

Given a Validator
When is_a_number is given a number
Then nothing happens.
#+end_src

#+begin_src js :noweb-ref is-a-number-case-1
// Given a Validator

When("is_a_number is given a number", function() {
  this.validate.is_a_number("good-number", faker.number.float());
  this.validate.is_a_number("good-number", 0);
});

Then("nothing happens.", function() {});
#+end_src

This is the case where we get what we wanted. I added a second check for ~0~ explicitly because I was originally using the [[https://developer.mozilla.org/en-US/docs/Glossary/Falsy][~falsy~]] check (~!(actual)~) but it turns out that 0 would be considered false if you do that so I added an explicit check to make sure I wasn't disallowing 0.

#+begin_src gherkin :noweb-ref is-a-number-scenario-2
Scenario: The expected number isn't a number.

Given a Validator
When an expected number isn't actually a number
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-a-number-case-2
// Given a Validator

When("an expected number isn't actually a number", function() {
  this.bad_call = function() {    
      this.validate.is_a_number("bad-number", faker.lorem.word());
  };
});

Then("it throws an Error.", function() {
  expect(this.bad_call.bind(this)).to.throw(Error);
});
#+end_src

I'm just checking for a string. I suppose there are other checks to be made, but since the ~Validator~ is only intended to validate my own code for mistakes, I don't suppose it really needs to be exhaustive.

#+begin_src gherkin :noweb-ref is-a-number-scenario-3
Scenario: The expected number wasn't assigned.

Given a Validator
When an expected number isn't assigned
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-a-number-case-3
// Given a Validator

When("an expected number isn't assigned", function() {
  this.bad_call = function() {
    this.validate.is_a_number("no-number", null);
  };
});

// Then it throws an error
#+end_src

This isn't explicitly needed, I think, since it falls within "non-number" but I wrote the tests as I made the ~SliderSettings~ and sometimes I would get the parameters out of order (I wish javascript had named variables) so I added ~null~ checks for the arguments to make it more obvious.


*** The Method

And here's the implementation.

#+begin_src js :noweb-ref validate-is-number
is_a_number(identifier, actual) {
  if ((!actual && actual !== 0) || isNaN(actual)) {
    throw Error(`"${identifier}" must be a number not "${actual}"`);
  };
}; // is_a_number
#+end_src

The first condition checks that the number isn't [[https://developer.mozilla.org/en-US/docs/Glossary/Falsy]['falsy']], but in javascript ~0~ is considered falsy so to allow zeros I added the check that it's not ~0~ if it's falsy. The conditional also checks if it is javascript's idea of a [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN][NaN]] using the global [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN][isNaN]]. This function coerces values to numbers (e.g. the string "120" is not Nan) so I originally used [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN][Number.isNaN]], since the documentation says that it /doesn't/ coerce values, but that turns out to mean that it just returns ~false~ without coercing the string... I suppose there's a reason for this, particularly since [[https://en.wikipedia.org/w/index.php?title=NaN&oldid=1175348130][~NaN~]] is meant for numeric data types, so a string is "not a number" but it can't be /NaN/, but whatever the reasion, it's something to remember, although it seems odd that, in being more strict, ~Number.isNaN~ ends up returning the same value as the global version.

** Is Set

This is for the cases where I have no particular type in the mind but a variable does need to be set to something.

*** Scenarios

#+begin_src gherkin :noweb-ref is-set-scenario-1
Scenario: The variable has a value set.

Given a Validator
When is_set is given a variable that's set
Then nothing happens.
#+end_src

#+begin_src js :noweb-ref is-set-case-1
// Given a Validator

When("is_set is given a variable that's set", function() {
  this.validate.is_set("set-variable", faker.lorem.word());
  this.validate.is_set("set-variable", 0);
  this.validate.is_set("set-variable", false);
});

// Then nothing happens.
#+end_src

Given the broad view of what I'm saying ~is_set~ should check for it'd be hard to check all the possibilities so this mostly checks that I didn't use a ~falsy~ check or something like that which would create false negatives.

#+begin_src gherkin :noweb-ref is-set-scenario-2
Scenario: The variable is empty.

Given a Validator
When is_set is given an empty variable
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-set-case-2
// Given a Validator

When("is_set is given an empty variable", function() {
  this.bad_call = function() {
    this.validate.is_set(null);
  };
});

// Then it throws an Error.
#+end_src

Checking for ~null~ should be the most common case, since I'm going to use this to validate an object and make sure it's attributes were all set.

#+begin_src gherkin :noweb-ref is-set-scenario-3
Given a Validator
When is_set is given an undefined variable
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-set-case-3
// Given a Validator

When("is_set is given an undefined variable", function() {
  this.bad_call = function() {
    this.validate.is_set(undefined);
  };
});

// Then it throws an Error.
#+end_src

I wouldn't think this would be something that needs to be checked, but since javascript just returns ~undefined~ instead or raising an error if you misspell a variable name, I guess it's useful.

*** The Method
This checks if the value is in whatever is in the ~emptiness~ array, which as of now has:

- ~null~
- ~undefined~
- ~NaN~

I'm not sure about that last one. I think I was trying to use all the ~falsy~ values that weren't likely to be actual values (like 0, ~false~), but now you can't use infinity either. Not that I can think of a case that I would, but maybe that'll have to be taken out later.

#+begin_src js :noweb-ref validate-is-set
is_set(identifier, actual) {
  if (this.emptiness.includes(actual)) {
    throw Error(`"${identifier} must be set, not "${actual}"`)
  };
}; //is_set
#+end_src

** Is An Integer

*** The Scenarios

#+begin_src gherkin :noweb-ref is-integer-scenario-1
Scenario: The variable has an integer

Given a Validator
When is_an_integer is given a variable with an integer
Then nothing happens.
#+end_src

#+begin_src js :noweb-ref is-an-integer-case-1
// Given a Validator

When("is_an_integer is given a variable with an integer", function() {
  this.validate.is_an_integer("is-integer", faker.number.int());
  this.validate.is_an_integer("is-integer", 1.0);
});

// Then nothing happens
#+end_src

Our happy-path case. The second check in the ~When~ is there to make it clearer that even though ~1.0~ smells like a float, ~Number.isInteger~ treats it like an integer.

#+begin_src gherkin :noweb-ref is-integer-scenario-2
Scenario: The variable has a string

Given a Validator
When is_an_integer is given a string
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-an-integer-case-2
// Given a Validator

When("is_an_integer is given a string", function() {
  this.bad_call = function() {
    this.validate.is_an_integer("not-integer", `${faker.number.int()}`);
  };
});

// Then it throws an Error.
#+end_src

I think this is the most likely error - it was passed a string. Interestingly, like the ~Number.isNaN~ function, the [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger][Number.isInteger]] function that I'm using also doesn't coerce strings so while "5" isn't not NaN, it also isn't an integer.

#+begin_src gherkin :noweb-ref is-integer-scenario-2a
Scenario: "is_an_integer" is given a float.

Given a Validator
When is_an_integer is given a float
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-an-integer-case-2a
// Given a Validator

When("is_an_integer is given a float", function() {
  this.bad_call = function() {
    this.validator.is_an_integer("float-not-integer", 5.5);
  };
});

// Then it throws an Error.
#+end_src

Since I showed above that /5.0/ is considered an integer I felt obliged to make sure that other floats aren't considered integers.

#+begin_src gherkin :noweb-ref is-integer-scenario-3
Scenario: The integer variable wasn't set.

Given a Validator
When an expected integer wasn't set
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-an-integer-case-3
// Given a Validator

When("an expected integer wasn't set", function() {
  this.bad_call = function() {
      this.validate.is_an_integer("no-integer", null);
  };
});

// Then it throws an Error.
#+end_src

*** The Method

This is, oddly, the only built-in that I could find that does type checks (but I didn't look that hard, and I was using DuckDuckGo so I might have found something using a different search engine).

#+begin_src js :noweb-ref validate-is-integer
is_an_integer(identifier, actual) {
  if (!Number.isInteger(actual)) {
    throw Error(`"${identifier}" must be an integer, not ${actual}`);
  };
}; // is_an_integer
#+end_src

** Is An Element's ID

This is what really started it all. I had some mysterious errors {{% lancelot "drawing a spiral" %}}generative-art-spiral{{% /lancelot %}} which turned out to be because I had changed a div ID in the HTML but not in the javascript. So this checks to see if there really an element with the ID. It doesn't check if it's the *right* ID, but I don't know that there's a simple way to do that anyway.

*** The Scenarios

#+begin_src gherkin :noweb-ref is-id-scenario-1
Scenario: A valid ID is given.

Given a Validator
When is_an_element_id is given a valid element ID
Then nothing happens.
#+end_src

#+begin_src js :noweb-ref is-element-case-1
// Given a Validator

When("is_an_element_id is given a valid element ID", function() {
  this.validate.is_an_element_id("good-id", VALID_ID);
});

// Then nothing happens.
#+end_src

Since I'm using JSDOM I needed to use a real ID to check if it was valid, not a random string.

#+begin_src gherkin :noweb-ref is-id-scenario-2
Scenario: An invalid ID is given.

Given a Validator
When is_an_element is given an invalid element ID
Then it throws an Error.
#+end_src

#+begin_src js :noweb-ref is-element-case-2
// Given a Validator

When("is_an_element is given an invalid element ID", function() {
  this.bad_call = function() {
    this.validate.is_an_element_id("bad-id", VALID_ID + "invalid");
  };
});

// Then it throws an Error.
#+end_src

Although I suppose the odds of a random string matching my ~div~ ID is pretty low, I thought that mangling the ID would be a better guaranty that it won't match than using ~faker~ to generate a string.

*** The Method
This relies on the built-in [[https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById][~document.getElementById~]] method (well, built-in when there's a browser).

#+begin_src js :noweb-ref validate-is-id
is_an_element_id(identifier, actual) {
  if (this.document.getElementById(actual) === null) {
    throw Error(`"${identifier}" isn't a valid ID - "${actual_id}"`);
  };
}; // is_an_id
#+end_src

* The Sliders Settings

#+begin_src plantuml :file ../files/posts/slider-settings-and-validator/slider_settings.png :exports none
!theme mars
class SliderSettings {
Number min
Number max
Number default_value
Number step_size
String label
Integer precision
String slider_div
String caption_div
Validator validator
Object document

check_rep()
}

SliderSettings o- Validator
SliderSettings o- document
#+end_src

#+RESULTS:
[[file:../files/posts/slider-settings-and-validator/slider_settings.png]]

[[img-url:slider_settings.png]]

The ~SliderSettings~ class holds the values for the ~Slidini~ class and optionally validates the values it's been given.

** The Scenario

#+begin_src gherkin :tangle ../tests/cucumber-tests/test-slider-settings-and-validator/features/slider_settings.feature :exports none
<<given-a-slider-settings>>

<<when-call-check-rep>>

<<it-checked-min>>

<<it-checked-max>>

<<it-checked-default>>

<<it-checked-step-size>>

<<it-check-label>>

<<it-checked-precision>>

<<it-checked-slider-div>>

<<it-checked-caption-div>>
#+end_src

Since there's only one method to call and it defers everything to the Validator I'm going to have one Scenario, but to try and make it easier to read I'm going to break up the Then-And statements within it, but I'm not going to break up the ~check_rep~ method itself so I'm not going to show the implementation under each test it satisfies, but just show the class definition in entirety after all the tests.

#+begin_src gherkin :tangle ../tests/cucumber-tests/test-slider-settings-and-validator/steps/slider_settings_steps.js :exports none
<<slider-settings-test-imports>>

<<setup-slider-settings-indexes>>
  
<<setup-slider-settings-step>>

  <<setup-slider-settings-methods>>

  <<setup-slider-settings-arguments>>

  <<setup-slider-settings-object>>

<<call-check-rep>>

<<min-check-step>>

<<max-check-step>>

<<default-check-step>>

<<step-size-check-step>>

<<check-step-label>>

<<check-step-precision>>

<<check-step-slider-div>>

<<check-step-caption-div>>
#+end_src

** The Testing

First we need to import some javascript. Even though I'm faking all the ~Validator~ methods I'm going to use on the Validator class I used the real definition because  I was hoping to figure out how to get ~sinon~ to copy all the methods automatically, but I didn't see anything indicating it can, so maybe next time I'll just make a fake object instead.

#+begin_src js :noweb-ref slider-settings-test-imports
import { expect } from "chai";
import { faker } from "@faker-js/faker";
import { Given, When, Then } from "@cucumber/cucumber";
import { fake, replace } from "sinon";
import { SliderSettings } from "../../../../javascript/slider.js";
import { Validator } from "../../../../javascript/validator.js";
#+end_src

Since the Validator's methods get called more than once I need to be able to know what (zero-based) index each call is - e.g. checking ~default_value~ is the third ~Validator.is_a_number~ call, so to retrieve the object to check that the call went as expected I need to get the ~sinon~ call object at index 2. So the ~IS~ object below holds the indices to get the calls for each property... it'll make more sense later.

#+begin_src js :noweb-ref setup-slider-settings-indexes
const IS = {
  NUMBER: { min: 0,
            max: 1,
            default_value : 2,
            step_size: 3,               
          },
  SET: {
    label: 0
  },
  INTEGER: {
    precision: 0
  },
  ELEMENT: {
    slider_div: 0,
    caption_div: 1
  }
}

const METHODS = ["is_a_number", "is_set", "is_an_integer", "is_an_element_id"];
#+end_src

The ~METHODS~ array holds the names of all of the Validator's methods that ~check_rep~ uses so that I can replace the Validator's methods in a loop instead of doing it separately for each one.

*** Setup The Slider Settings

Now I'll build the ~SliderSettings~ with the faked ~Validator~ methods in the cucumber ~Given~ function. I guess you could do this in a ~Before~ function too, but then what would I put in the ~Given~?

#+begin_src gherkin :noweb-ref given-a-slider-settings
Feature: Slider Settings

Scenario: check_rep is called.

Given a Slider Settings
#+end_src

Since all the methods are faked, I don't need a mock ~document~ the way I did for the ~Validator~ tests.

#+begin_src js :noweb-ref setup-slider-settings-step
Given("a Slider Settings", function() {
  this.validator = new Validator({});
#+end_src

Now that I have a ~Validator~ instance, I can replace all the methods to test with ~fakes~.

#+begin_src js :noweb-ref setup-slider-settings-methods
for (const method of METHODS) {
    replace(this.validator, method,
          fake.returns(null));    
}
#+end_src

Next, I'll fake the arguments passed to the ~SliderSettings~ object and store them in the ~World~ ~this~ so that I can check that they were passed to the validator as expected.

#+begin_src js :noweb-ref setup-slider-settings-arguments
this.min = faker.number.float();
this.max = faker.number.float();
this.default_value = faker.number.float();
this.step_size = faker.number.float();
this.label = faker.lorem.words();
this.precision = faker.number.int();
this.slider_div = faker.lorem.word();
this.caption_div = faker.lorem.word();  
#+end_src

Finally, I can create the ~SliderSettings~ to test.

#+begin_src js :noweb-ref setup-slider-settings-object
this.settings = new SliderSettings(this.min,
                                   this.max,
                                   this.default_value,
                                   this.step_size,
                                   this.label,
                                   this.precision,
                                   this.slider_div,
                                   this.caption_div,
                                   this.validator);
});
#+end_src

*** Calling Check Rep

This is the only call to ~SliderSettings~ I make.

#+begin_src gherkin :noweb-ref when-call-check-rep
When check_rep is called
#+end_src

#+begin_src js :noweb-ref call-check-rep
When("check_rep is called", function() {
  this.settings.check_rep();
});
#+end_src

*** Min Check

#+begin_src gherkin :noweb-ref it-checked-min
Then it checked the min
#+end_src

#+begin_src js :noweb-ref min-check-step
// Given a Slider Settings
// When check_rep is called

Then("it checked the min", function() {
  expect(this.validator.is_a_number.getCall(IS.NUMBER.min).calledWith(
    "min", this.min
  )).to.be.true;  
});
#+end_src

~this.validator.is_a_number~ is a faked method which allows us to check the arguments passed to it by getting the call object using ~getCall~ and checking the arguments with ~calledWith~. In this case checking ~min~ is the first call to ~is_a_number~ so I'm passing ~0~ to ~getCall~, retrieving it from the ~IS~ object I created earlier (using ~IS.NUMBER.min~).

I'm not crazy about the need to pass in strings, but since they always match the variable name I guess it's easy enough to see any typos.

The rest of the checks are pretty much the same thing but with different variables so I'll stop the commentary for a while.

*** Max Check

#+begin_src gherkin :noweb-ref it-checked-max
And it checked the max
#+end_src

#+begin_src js :noweb-ref max-check-step
Then("it checked the max", function() {
  expect(this.validator.is_a_number.getCall(IS.NUMBER.max).calledWith(
    "max", this.max
  )).to.be.true;
});
#+end_src

*** Default Value

#+begin_src gherkin :noweb-ref it-checked-default
And it checked the default_value
#+end_src

#+begin_src js :noweb-ref default-check-step
Then("it checked the default_value", function() {
  expect(this.validator.is_a_number.getCall(IS.NUMBER.default_value).calledWith(
    "default_value", this.default_value
  )).to.be.true;
});
#+end_src
*** Step Size

#+begin_src gherkin :noweb-ref it-checked-step-size
And it checked the step_size
#+end_src

#+begin_src js :noweb-ref step-size-check-step
Then("it checked the step_size", function() {
  expect(this.validator.is_a_number.getCall(IS.NUMBER.step_size).calledWith(
    "step_size", this.step_size
  )).to.be.true;
});
#+end_src
*** Label

#+begin_src gherkin :noweb-ref it-check-label
And it checked the label
#+end_src

#+begin_src js :noweb-ref check-step-label
Then("it checked the label", function() {
  expect(this.validator.is_set.getCall(IS.SET.label).calledWith(
    "label", this.label
  )).to.be.true;
});
#+end_src

*** Precision

#+begin_src gherkin :noweb-ref it-checked-precision
And it checked the precision
#+end_src

#+begin_src js :noweb-ref check-step-precision
Then("it checked the precision", function() {
  expect(this.validator.is_an_integer.getCall(IS.INTEGER.precision).calledWith(
    "precision", this.precision
  )).to.be.true;
});
#+end_src

*** Slider Div

#+begin_src gherkin :noweb-ref it-checked-slider-div
And it checked the slider_div
#+end_src

#+begin_src js :noweb-ref check-step-slider-div
Then("it checked the slider_div", function() {
  expect(this.validator.is_an_element_id.getCall(IS.ELEMENT.slider_div).calledWith(
    "slider_div", this.slider_div
  )).to.be.true;
});
#+end_src

*** Caption Div

#+begin_src gherkin :noweb-ref it-checked-caption-div
And it checked the caption_div.
#+end_src

#+begin_src js :noweb-ref check-step-caption-div
Then("it checked the caption_div.", function() {
  expect(this.validator.is_an_element_id.getCall(IS.ELEMENT.caption_div).calledWith(
    "caption_div", this.caption_div
  )).to.be.true;
});
#+end_src

** The Slider Settings Implementation

Now that we have the tests, I'll implement the slider settings.

#+RESULTS:
[[img-url:slider_settings.png]]

The ~SliderSettings~ holds the settings to build ~Slidini~, the Slider and Caption holder. It really could be done with a plain object (which is what it was) but I decided to add a validator to make sure that I was getting all the parameters right.

#+begin_src js :noweb-ref slider-settings-class
class SliderSettings {
  constructor(min, max, default_value, step_size,
              label, precision,
              slider_div, caption_div,
              validator, document) {
    this.min = min;
    this.max = max;
    this.default_value = default_value;
    this.step_size = step_size;
    this.label = label;
    this.precision = precision;
    this.slider_div = slider_div;
    this.caption_div = caption_div;
    this.confirm = validator;
    this.document = document;
  }; // constructor

  check_rep(){
    this.confirm.is_a_number("min", this.min);
    this.confirm.is_a_number("max", this.max);
    this.confirm.is_a_number("default_value", this.default_value);
    this.confirm.is_a_number("step_size", this.step_size);
    this.confirm.is_set("label", this.label);
    this.confirm.is_an_integer("precision", this.precision);
    this.confirm.is_an_element_id("slider_div", this.slider_div);
    this.confirm.is_an_element_id("caption_div", this.caption_div);
  }; // check_rep
}; // SliderSettings
#+end_src

* Slidini
#+begin_src js :tangle ../javascript/slidini.js :exports none
<<slidini>>

  <<slidini-constructor>>

  <<slidini-get-slider>>

  <<slidini-get-caption>>

  <<slidini-update-caption>>

export { Slidini }
#+end_src

** The Class Declaration
#+begin_src js :noweb-ref slidini
class Slidini {
  _slider = null;
  _caption = null;
#+end_src

** The Constructor

#+begin_src js :noweb-ref slidini-constructor
constructor(settings, p5) {
  this.settings = settings;
  this.p5 = p5;
} // constructor
#+end_src

** The Slider

#+begin_src js :noweb-ref slidini-get-slider
get slider() {
  if (this._slider === null) {
    // create the slider
    this._slider = this.p5.createSlider(
      this.settings.min,
      this.settings.max,
      this.settings.default_value,
      this.settings.step_size,
    );

    // attach it to the div tag
    this._slider.parent(this.settings.slider_div);

    // set the callback to change label on update
    this._slider.input(() => this.update_caption());

    // add the label to the slider
    this.update_caption();
  }
  return this._slider;
}
#+end_src

** The Caption

#+begin_src js :noweb-ref slidini-get-caption
get caption() {
  if (this._caption === null) {
    this._caption = this.p5.select(this.settings.caption_div);
  }
  return this._caption;
}
#+end_src

** The Caption Updater

#+begin_src js :noweb-ref slidini-update-caption
update_caption() {
  this.caption.html(
    `${this.settings.label}: ` +
      `${this.slider.value().toFixed(this.settings.precision)}`);
} // update_caption
#+end_src

* Links
- Document: getElementById() method - Web APIs | MDN [Internet]. 2023 [cited 2023 Oct 3]. Available from: https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementById
  
- isNaN() - JavaScript | MDN [Internet]. 2023 [cited 2023 Oct 3]. Available from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN

- NaN - JavaScript | MDN [Internet]. 2023 [cited 2023 Oct 3]. Available from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN

- NaN. In: Wikipedia [Internet]. 2023 [cited 2023 Oct 3]. Available from: https://en.wikipedia.org/w/index.php?title=NaN&oldid=1175348130
    
- Number.isNaN() - JavaScript | MDN [Internet]. 2023 [cited 2023 Oct 3]. Available from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN

- Number.isInteger() - JavaScript | MDN [Internet]. 2023 [cited 2023 Oct 3]. Available from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
